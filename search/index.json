[{"content":"","href":"/","title":"Home"},{"content":"","href":"/jupyter/","title":"Jupyter"},{"content":"","href":"/other/","title":"Other"},{"content":"","href":"/science/","title":"Science"},{"content":"","href":"/software/","title":"Software"},{"content":" Contents\n Introduction: the case for Pandas extensions How to write a Pandas extension Extending Pandas with Pandas-flavor  Introduction: the case for Pandas extensions Pandas is Python\u0026rsquo;s DataFrame library. There are many reasons why should be using DataFrame\u0026rsquo;s in your data science workflow, but I\u0026rsquo;ll have to leave that for another article. In this article, I\u0026rsquo;ll show you how to tailor Pandas to your business, research, or personal workflow using Pandas\u0026rsquo; extension API.\nPandas is a powerful library. You can read data from various file types and manipulate and plot that using a highly memory-efficient data structure and API. It has become a foundational library in various scientific Python stacks and the de facto tool for data science in many companies and research institutions around the world.\nPandas is also a general library. You\u0026rsquo;ll find Pandas at various financial institutions, research institutions, classrooms, etc. To meet the needs of these many different domains, the core Pandas development team has worked hard to keep the API fairly general.\nThus, Pandas does not (and should not) provide domain-specific functionality. I would wager that the core Pandas team has turned away many contributions from people who trieds to add functions for their special use-case. While these types of additions are great to see, they don\u0026rsquo;t belong in the core Pandas API.\nSo, where do my domain-specific additions belong?\nThey belong in a Pandas extension. An extension is a separate piece of Python code, maybe an object or function, that automatically hooks into the Pandas API when imported.\nLet\u0026rsquo;s imagine, for example, you\u0026rsquo;re a financial consultant, and you\u0026rsquo;ve developed a nice set of functions to analyze financial data into a Pandas DataFrame. This is a lot of work. You wrote your own read_portfolio and to_portfolio functions to read/write your data, following Pandas\u0026rsquo; API design. You have code that sets each column to the correct data-type. You\u0026rsquo;ve formatted the date-time columns appropriately (I always have to look this up!). You have functions that slice out the capital gains for your clients. Maybe you even wrote some handy Matplotlib code to visualize your clients portfolio in a simple way.\nHow do you share this code with others? Clearly, this does not belong in the core Pandas library. A \u0026ldquo;finance DataFrame\u0026rdquo; only serves a small subset of Pandas users. However, your code follows Pandas\u0026rsquo; API design and directly affects Pandas\u0026rsquo; core objects. You want your users to treat this code like its \u0026ldquo;Pandas for finance\u0026rdquo; (or whatever domain you\u0026rsquo;re in).\nThat\u0026rsquo;s when you should write a pandas extension. Here\u0026rsquo;s what your Pandas extension might look like:\nimport pandas # Import pandas import pandas_finance # Import your extension df = pandas.DataFrame({ # Create a DataFrame \u0026#34;value\u0026#34;: [5, -5, 45, 65, 30] \u0026#34;gain_or_loss\u0026#34;: [5, -10, 50, 20, -35] }) # Get rows with negative numbers in  # \u0026#34;gain_or_loss\u0026#34; column. df.finance.get_losses() # That dataframe has a `finance` accessor. By simply importing pandas_finance in the example above, the pandas.DataFrame has a finance attribute (also called an \u0026ldquo;accessor\u0026rdquo;) and an extra method, get_losses. The user acts directly on their DataFrame. They can all the \u0026ldquo;finance\u0026rdquo; attribute, hit tab, and see all the special functions you\u0026rsquo;ve added.\nPandas extensions are meant to \u0026ldquo;feel\u0026rdquo; like Pandas code, even if they don\u0026rsquo;t come from the core Pandas library. They live as separate Python packages that users can install and import. When they are imported, they automatically \u0026ldquo;patch\u0026rdquo; their custom functionality onto Pandas\u0026rsquo; objects.\nThere are many Pandas extensions that exist today. Here is a non-exhaustive list in case you\u0026rsquo;re interested:\n GeoPandas: Pandas for geographic data and information. PhyloPandas: the Pandas DataFrame for phylogenetics. Pdvega: Vega-lite plots from Pandas DataFrames. pyjanitor: data \u0026ldquo;cleaning\u0026rdquo; API for Pandas DataFrames. Pandas\u0026rsquo; plot API: yes, this is part of Pandas\u0026rsquo; core library, but acts like an extension.  How to write a Pandas Extension. I recommend you use the Python library, Pandas-flavor; I\u0026rsquo;ll explain why in a minute. (Full disclosure: I am the original creator of this library.)\nFirst, Pandas v0.24 introduced a new, simpler API for creating Pandas extensions. Essentially, it covered the boilerplate code for attaching extensions under the hood. It included two Python decorators: register_dataframe_accessor and register_series_accessor. Let me break down these magical functions.\n The \u0026ldquo;register\u0026rdquo; part acknowledges that these functions \u0026ldquo;monkey-patch\u0026rdquo; or add functionality to Pandas DataFrame or Series objects after Pandas has been imported.\n An \u0026ldquo;accessor\u0026rdquo; is an object that attaches to a Pandas object that can access and \u0026ldquo;mutate\u0026rdquo; (i.e. change) the object. In the example above, the finance attribute is an accessor.  As an example, let\u0026rsquo;s create the finance extension above using register_dataframe_accessor. We\u0026rsquo;ll put this code inside a file named pandas_finances.py.\n# Import pandas\u0026#39;s extension API from pandas.api.extensions import register_dataframe_accessor @register_dataframe_accessor(\u0026#34;finance\u0026#34;) class FinanceAccessor: \u0026#34;\u0026#34;\u0026#34;Extra methods for finance dataframes.\u0026#34;\u0026#34;\u0026#34; def __init__(self, df): self._df = df def print_losses(self): # Slice out values less than 1. df = self._df losses = df[df[\u0026#34;gains_and_losses\u0026#34;] \u0026lt; 0] return losses When we import pandas_finances (like in the example before), a finance accessor will appear on all Pandas DataFrames in this session.\nTo write such an extension, you\u0026rsquo;ll need:\n To give the accessor a name, i.e. the DataFrame\u0026rsquo;s attribute you\u0026rsquo;ll call. You\u0026rsquo;ll pass this name as an argument to the register_dataframe_accessor. To create an accessor class, a Python object. Name it whatever you like. It must have an __init__ method whose only argument is the Pandas DataFrame (or Series, if using register_series_accessor). To store the Pandas object as a hidden attribute on the Accessor (prefix the attribute with an underscore); I suggest self._df. To add your methods and attributes as members of the Accessor class. You can access and mutate the dataframe by affecting the self._df attribute.  That\u0026rsquo;s it! You can start writing your own Pandas extension today!\nExtending Pandas-Flavor As I mentioned, Pandas added this extension API in v0.24, which means this won\u0026rsquo;t work with earlier versions of Pandas. That\u0026rsquo;s one reason why I wrote Pandas-flavor.\nPandas-flavor backports this extension API to earlier versions of Pandas. You can import the same decorators, register_dataframe_accessors and register_series_accessors and it will work with most versions of Pandas. Just replace the the import statements above:\nfrom pandas_flavor import register_dataframe_accessor Another reason I wrote Pandas-flavor is to\n[WIP]\n","href":"/software/pandas-flavor/","title":"Writing your own flavor of Pandas"},{"content":" \u0026ldquo;If you want to go fast, go alone. If you want to go far, go together.\u0026rdquo;\n A few weeks ago, I had the opportunity to join many members of the Project Jupyter\u0026rsquo;s core development team in Washington DC for our annual team meeting. A huge thank you to Dr. Lorena Barba for hosting our team at George Washington University for the week.\nThis was an incredible experience.\nI counted ~20 core contributors representing 9 different countries in the room. Both new and long-time contributors were present. Fernando Perez, the creator of IPython (in 2001) and co-creator of Project Jupyter, was there, as well as Letitia Portella, a new team member that joined through Outreachy four months earlier. The best part\u0026ndash;it did not matter what your background was; everyone had an voice.\nI won\u0026rsquo;t much time to talking about the specific things we discussed during the week (you can find more detail in the links at the bottom). I will just say\u0026ndash;I was amazed by how many times phrases like \u0026ldquo;empower everyone\u0026rdquo; and \u0026ldquo;for the greater good\u0026rdquo; were mentioned thoughout the week.\nThere\u0026rsquo;s one thing that is certain; the Jupyter team cares deeply for its community.\nMost of our conversations were centered around one question: how do we build a governance model that scales and protects Project Jupyter\u0026rsquo;s community?\nThe Jupyter ecosystem is a global community; that comes with many challenges. Until now, Jupyter has suffered from the \u0026ldquo;tyranny of structurelessness\u0026rdquo;. But as Jupyter finds itself pulled by various, major stake-holders like IBM, Netflix, Amazon, Microsoft, Google, etc., the community will need to invest time, energy, and initiative into establishing a structure that protects and sustains its members. During our week together, we constructed some actionable next steps. Now, we just need to make them happen. To keep up on things that are happening around Jupyter, I strongly recommend you check out our Discourse page.\nFurther reading I recommend from this week:\n Chris Holdgraf\u0026rsquo;s thoughts: https://predictablynoisy.com/jupyter-team-meeting-2019 Jupyter Discourse thread: https://discourse.jupyter.org/t/2019-in-person-team-meeting-updates-and-notes/458  ","href":"/jupyter/jupyter-team-meeting/","title":"Jupyter Team Meeting 2019"},{"content":"Finally starting a blog. Thank you to Letitia Portella and Saul Shanabrook for pushing to make it happened.\nI\u0026rsquo;m planning to use this site to share three major types of content.\n I\u0026rsquo;ll announce software that I\u0026rsquo;ve published or review software someone else published.\n I\u0026rsquo;ll highlight things I come across in basic science and research domains. Since my background is in science, I\u0026rsquo;ll use this blog to stay connected to that community.\n I\u0026rsquo;ll try to record useful tricks, hints, and details I found useful in my own pursuit to be a better developer. There is nothing more frustrating than the scenario so accurately depicted in Randall Monroe\u0026rsquo;s XKCD comic:\n\n  ","href":"/other/first-post/","title":"Hello, world."},{"content":"","href":"/authors/","title":"Authors"},{"content":"","href":"/categories/","title":"Categories"},{"content":"","href":"/page/","title":"Pages"},{"content":"","href":"/search/","title":"Search"},{"content":"","href":"/series/","title":"Series"},{"content":"","href":"/tags/","title":"Tags"},{"content":"","href":"/tags/jupyter/","title":"jupyter"},{"content":"","href":"/tags/open-source-community/","title":"open-source community"},{"content":"","href":"/tags/pandas/","title":"pandas"},{"content":"","href":"/tags/xkcd/","title":"xkcd"},{"content":"","href":"/authors/zsailer/","title":"zsailer"}]
